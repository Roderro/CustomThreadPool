# CustomThreadPool - Документация

## Обзор

`CustomThreadPool` - это настраиваемая реализация пула потоков, предоставляющая расширенный контроль над управлением
потоками, выполнением задач и обработкой отказов. Реализует интерфейс `CustomExecutor` и предлагает такие функции как
динамическое масштабирование потоков, поддержание резервных потоков и специальную очередь для отклоненных задач.

## Основные возможности

- **Настраиваемые размеры пула**: Установка базового и максимального количества потоков
- **Время жизни потоков**: Потоки сверх базового размера завершаются после периода бездействия
- **Минимальное количество резервных потоков**: Поддержание заданного числа готовых к работе потоков
- **Очередь задач**: Каждый worker имеет свою ограниченную очередь задач
- **Обработка отклоненных задач**: Настраиваемая политика с запасной очередью
- **Равномерное распределение задач**: Round-robin алгоритм распределения задач между worker'ами
- **Динамическое масштабирование**: Автоматическая регулировка количества потоков
- **Управление завершением работы**: Варианты плавного и немедленного завершения

## Параметры конфигурации

| Параметр          | Описание                                 |
|-------------------|------------------------------------------|
| `corePoolSize`    | Базовое количество потоков в пуле        |
| `maxPoolSize`     | Максимальное количество потоков          |
| `keepAliveTime`   | Время бездействия до завершения потока   |
| `timeUnit`        | Единица измерения времени                |
| `queueSize`       | Размер очереди задач каждого worker'а    |
| `minSpareThreads` | Минимальное количество резервных потоков |
| `threadFactory`   | Фабрика для создания потоков             |
| `handler`         | Обработчик отклоненных задач             |

## Использование

### Базовая инициализация

```java
CustomThreadPool pool = new CustomThreadPool(
        5,  // corePoolSize
        10, // maxPoolSize
        60, // keepAliveTime
        TimeUnit.SECONDS, // timeUnit
        100, // queueSize
        2    // minSpareThreads
);
```

### Отправка задач

```java
// Выполнение Runnable
pool.execute(() ->System.out.

println("Выполнение задачи"));
// Отправка Callable с получением Future
Future<String> future = pool.submit(() -> "Результат задачи");
```

### Завершение работы

```java
// Плавное завершение
pool.shutdown();
// Немедленное завершение
pool.shutdownNow();
```

## Обработка отклоненных задач

При полной загрузке пула:

- По умолчанию задачи попадают в специальную очередь отклоненных задач
- Worker'ы берут задачи из этой очереди при опустошении основной
- Возможна реализация собственного обработчика через `CustomRejectedExecutionHandler`

## Мониторинг

Доступные метрики:

- `getThreadCount()` - Текущее количество активных потоков
- `getRejectedTasksQueue()` - Доступ к очереди отклоненных задач

## Особенности реализации

- **Управление worker'ами**: Каждый Worker имеет свою `BlockingQueue` для задач
- **Фабрика потоков**: По умолчанию используется `CustomThreadFactory`
- **Балансировка нагрузки**: Round-robin алгоритм распределения
- **Динамическое масштабирование**: Автоматическое добавление и удаление worker'ов
- **Резервные потоки**: Поддержание минимального числа готовых потоков

## Рекомендации

- Устанавливайте `minSpareThreads` в соответствии с ожидаемыми скачками нагрузки
- Мониторьте размер очереди отклоненных задач для корректировки параметров
- Реализуйте собственную `ThreadFactory` для лучшего контроля
- Всегда завершайте работу пула по окончании использования

## Ограничения

- Очередь отклоненных задач не имеет ограничения размера
- Не предназначен для задач с экстремально низкой задержкой

## Тестирование
В папке `src/test/java/sf/hw/CustomThreadPoolTest/CorrectWorkTest` написаны unit тесты для проверки основных функции данного CustomThreadPool.
Для тестирования необходимо установить необходимые зависимости из pom.xml и запустить mvn test или запустить в ide.

# Анализ производительности thread pool'ов: кастомные vs стандартные vs промышленные решения

## Методология тестирования

Тестирование производилось с использованием методов из класса `src/test/java/sf/hw/CustomThreadPoolTest/PerfomanceTest/ThreadPoolsPerformanceTest.java`. Результаты прогонки тестов
можно найти в папке `resultPerformance`.
Для обеспечения корректного сравнения всех thread pool'ов использовались следующие единые параметры конфигурации:

**Параметры тестирования:**
- Система: 20 ядер процессора
- Количество задач: 10,000
- Итераций прогрева: 2
- Тестовых итераций: 4
- Замеряемый параметр: общее время выполнения (мс) и кол-во использованной памяти(KB)

### Конфигурация очереди

- **Тип очереди**: `LinkedBlockingQueue` без явного ограничения емкости (фактически `Integer.MAX_VALUE`)
- **Принцип работы**: Соответствует реализации кастомного пула, где очередь отклоненных задач не ограничена

### Параметры пулов

| Параметр        | Значение                   |
|-----------------|----------------------------|
| `corePoolSize`  | Количество ядер процессора |
| `maxPoolSize`   | `corePoolSize × 2`         |
| `keepAliveTime` | 60 секунд                  |

### Результаты
Полные результаты доступны в `/resultPerformance`. Тестовый класс ThreadPoolsPerformanceTest позволяет воспроизвести все представленные измерения и провести дополнительный анализ для конкретных use-cases.
#### Сравнительные показатели:
| Тест                  | CustomWithoutSpare  | CustomWithSpare  | ThreadPoolExecutor | Tomcat | Jetty   |
|-----------------------|---------------------|------------------|--------------------|--------|---------|
| Базовый (ms)          | 2780                | 1428             | 2656               | 2668   | 1337    |
| Высокая нагрузка(ms)  | 2471                | 2426             | 4996               | 5025   | 2513    |
| Длительные задачи(ms) | 5525                | 2765             | 5432               | 5542   | 2765    |
| Короткие задачи(ms)   | 31                  | 33               | 5                  | 4      | 6       |
| Память (KB)           | 954                 | 1038             | 580                | 510    | 510     |

## Детальный анализ

### 1. Базовый тест производительности
- **Лидер**: Jetty ThreadPool (1337 мс) - в 2 раза быстрее стандартных реализаций
- Кастомный пул с резервами показал сравнимую с Jetty производительность (1428 мс)
- Стандартные пулы (ThreadPoolExecutor/Tomcat): ~2650 мс (на 85% медленнее лидера)

### 2. Тест под высокой нагрузкой
**Оптимальные решения**:
- Кастомный пул с резервами (2426 мс)
- Jetty ThreadPool (2513 мс)

Стандартные пулы показали в 2 раза худшие результаты (~5000 мс)

**Вывод**: Кастомная реализация с резервными потоками эффективно справляется с пиковыми нагрузками

### 3. Длительные задачи
**Лучшая производительность**:
- Jetty и CustomWithSpare (по 2765 мс)
- Стандартные пулы: ~5500 мс (в 2 раза медленнее)

**Особенность**: Кастомный пул без резервов показал худший результат (5525 мс)

### 4. Короткоживущие задачи
**Лидеры**:
- Tomcat (4 мс)
- ThreadPoolExecutor (5 мс)
- Кастомные реализации: 31-33 мс (в 6-8 раз медленнее)

**Вывод**: Для микроопераций стандартные решения предпочтительнее

### 5. Использование памяти
**Наиболее экономичные**:
- Tomcat и Jetty (по 510 КБ)
- ThreadPoolExecutor (580 КБ)
- Кастомные пулы: 954-1038 КБ (на 85-100% больше памяти)

**Компромисс**: CustomWithoutSpare vs стандартные пулы (разница ~400 КБ)

## Рекомендации по применению

### Для высоконагруженных систем:
- **Оптимальный выбор**: Jetty ThreadPool
  - Лучшая производительность в 3 из 4 тестов
  - Оптимальное использование памяти
- **Альтернатива**: CustomThreadPoolWithSpare
  - Сопоставимая производительность с Jetty
  - Возможность тонкой настройки под специфические требования

### Для систем с микротасками:
- ThreadPoolExecutor/Tomcat ThreadPool:
  - Лучшая производительность на коротких задачах
  - Стабильное потребление памяти

### При ограниченных ресурсах:
- Jetty ThreadPool:
  - Лучший баланс производительности и потребления памяти
- CustomThreadPoolWithoutSpare:
  - Приемлемая альтернатива при необходимости кастомной логики

## Заключение
- Кастомный пул с резервными потоками подтвердил свою эффективность:
  - Сопоставим с Jetty в большинстве тестов
  - На 40-50% быстрее стандартных реализаций
  - Подходит для систем с переменной нагрузкой
- Jetty ThreadPool остается эталоном:
  - Лучшие показатели в 3 из 5 тестов
  - Оптимальное использование ресурсов
  - Рекомендован для production-систем
- Стандартные пулы сохраняют преимущества:
  - Для задач с высокой частотой коротких операций
  - В системах с жесткими требованиями к потреблению памяти

Полные результаты доступны в `/result_31.03.2025-17_57.txt`. Тестовый класс `ThreadPoolPerformanceTest` позволяет воспроизвести измерения и адаптировать тесты под конкретные требования.

# Исследование производительности конфигураций пула потоков

## Методология тестирования
**Тестовый класс:** `src/test/java/sf/hw/ThreadPoolStatePerformanceTest.java`

**Параметры тестирования:**
- Система: 20 ядер процессора
- Количество задач: 10,000
- Итераций прогрева: 2
- Тестовых итераций: 4
- Замеряемый параметр: общее время выполнения (мс)

## Результаты тестирования
Полные результаты доступны в `/resultStatePerformance`. Тестовый класс `CustomThreadPoolStatePerformanceTest` позволяет воспроизвести все представленные измерения и провести дополнительный анализ для конкретных use-cases.

## Ключевые выводы

### Оптимальные параметры (ТОП-3 конфигурации)
1. **Конфигурация 18** (738 ms)
  - Ядра: 20
  - Макс.потоков: 80 (+300%)
  - Время жизни: 500ms
  - Очередь: 200
  - Резерв: 10 потоков

2. **Конфигурация 10** (1293 ms)
  - Ядра: 20
  - Макс.потоков: 40 (+100%)
  - Время жизни: 500ms
  - Очередь: 200
  - Резерв: 2 потока

3. **Конфигурация 17** (1306 ms)
  - Ядра: 20
  - Макс.потоков: 40 (+100%)
  - Время жизни: 1000ms
  - Очередь: 100
  - Резерв: 1 поток

### Анализ результатов
- **Размер пула:**
  - Лучшие результаты при `corePoolSize` = количеству ядер (20)
  - Увеличение `maxPoolSize` до 80 дало максимальный прирост

- **Очередь задач:**
  - Оптимальный размер 100-200
  - Слишком большие очереди (10,000) ухудшают производительность

- **Резервные потоки:**
  - 1-4 потока - оптимально

- **Время жизни:**
  - 500-1000ms - оптимальный диапазон
  - Слишком короткое (10ms) приводит к частому созданию потоков